//#include <iostream>//#include <windows.h>//#include <cstring>//#include <algorithm>//using namespace std;//// функция перевода текстового числа number имеющего сист. счисл. osn  в двоичное число //int ToBinary(char* number, int osn)//{//    int res = 0;//    for (int i = 0; number[i] != 0; i++)//    {//        res *= osn;//        if (number[i] <= '9')//            res += number[i] - '0'; // цифры '0' - '9'//        if (number[i] >= 'A')//            res += number[i] - 'A' + 10; // буквы 'A' - 'Z'//    }//    return res;//}//// функция перевода из двоичного числа в текстовое число number в сист. счисл. osn //void FromBinary(int n, char* number, int osn)//{//    int i = 0;//    while (n != 0)//    {//        int digit = n % osn;//        if (digit <= 9)//            number[i] = '0' + digit; // цифры '0' - '9'//        else//            number[i] = digit - 10 + 'A'; // буквы 'A' - 'Z'//        i++;//        n /= osn;//    }//    number[i] = 0;//    reverse(number, number + strlen(number));//}//int main()//{//    int p, q;//    char numberp[20], numberq[20];//    cout << "vvedite p ";//    cin >> p >> numberp;//    cout << "vvedite q ";//    cin >> q >> numberq;//    int A = ToBinary(numberp, p);//    int B = ToBinary(numberq, q);//    int C = 2 * A * A + 3 * A * B;//    cout << "v desyatichnoi C =  " << C << endl;//    char result[20];//    cout << "resultat v r  ";//    int r; cin >> r;//    FromBinary(C, result, r);//    cout << result << endl;//    return 0;//}//#include<iostream>//#include<math.h>//using namespace std;//double f(double x)//{//	return (0.1 * x * x - exp(x));//}//int chord(double a, double b, double* c, double eps)//{//	int k = 0;//	do{//		*c = a - f(a) / (f(b) - f(a)) * (b - a);//		if (f(*c) * f(a) > 0)a = *c;//		else b = *c;//		k++;//	} //	while (fabs(f(*c)) >= eps);//	return k;//}//double fi(double x, double L)//{//	return (x+L*f(x));//}//int iterat(double* x, double L, double eps)//{//	int k = 0; double x0;//	do{//		x0 = *x;//		*x = fi(x0, L);//		k++;//	} //	while (fabs(x0 - *x) >= eps);//	return k;//}//int main()//{//	double A, B, X, P;//	double ep = 0.001;//	int K;//	cout << "a = "; cin >> A;//	cout << "b = "; cin >> B;//	cout << "metog chord: ";//	K = chord(A, B, &X, ep);//	cout << "x = " << X<<endl;//	cout << "kol-vo iterat k = " << K << endl;//	cout << "metog iterat: " << endl;//	X = A;//	cout << "L = "; cin >> P;//	K = iterat(&X, P, ep);//	cout << "x = " << X<<endl;//	cout << "kol-vo iterat k = " << K << endl;//	return 0;//}////////2.1//#include<iostream>//#include<iomanip>//#include<ctime>//using namespace std;//void f_rand(int** tf, int nf, int mf, int r_min, int r_max)//{//	srand((unsigned int)time(NULL));//	for (int i = 0; i < nf; i++)//		for (int j = 0; j < mf; j++)//		tf[i][j]=rand() % (r_max - r_min) + r_min;//	return;//}//void f_print(int** tf, int nf, int mf)//{//	cout << endl;//	for (int i = 0; i < nf; i++) {//		for (int j = 0; j < mf; j++)//			cout << setw(6) << tf[i][j];//		cout << endl;//	}//	return;//}//bool check(int N)//{//	int d = 0, dold = 0;//	dold = N % 10;//	while (N != 0)//	{//		d = N % 10;//		if (d != dold)//		{//			return false;//		}//		N = N / 10;//		dold = d;//	}//	return true;//}//int main()//{	//double** c;	//int n, m,k,minn=9999;	//float pr = 1,summa=0;	//cout << "strok "; cin >> n;	//cout << "stolbcov "; cin >> m;	//cout << "stolbcov k "; cin >> k;	//int **t1 = new int *[n];	//for (int i = 0; i < n; i++)	//t1[i] = new int[m];	//int **t2 = new int *[m];	//for (int i = 0; i < m; i++)	//t2[i] = new int[k];	//f_rand(t1, n, m, 10, 99);	//cout << "ishod massiv B";	//f_print(t1, n, m);	//f_rand(t2, m, k, 10, 99);	//cout << "ishod massiv C";	//f_print(t2, m, k);//	for (int i = 0; i < n; i++)//	{//		for (int j = 0; j < m; j++)//		{//		pr *= t1[i][j];//		}//	}//	for (int i = 1; i < n-1; i++)//	{//		for (int j = 1; j < m-1; j++)//		{//		summa+= t1[i][j];//		}//	}//	for (int i = 0; i < n; i++)//	{//		for (int j = 0; j < m; j++)//		{//			if (check(t1[i][j] == true && minn > t1[i][j]))//			{//				minn = t1[i][j];//			}//		}//	}////////	c = new double* [n];//	for (int i = 0; i < n; i++)//	{//		c[i] = new double[k];//		for (int j = 0; j < k; j++)//		{//			c[i][j] = 0;//			for (int z = 0; z < k; z++) //				c[i][j] += t1[i][z] * t2[z][j];//			//		}//	}////	cout << "proizved matrix" << endl;//	for (int i = 0; i < n; i++)//	{//		for (int j = 0; j < k; j++)//			cout << c[i][j] << " ";//		cout << endl;//	}////	cout << "proisvedenie = " << pr << endl;//	cout << "summa vne perimetra " << summa<<endl;//	cout << "min chislo " << minn;//	return 0;//	delete []t1;//	delete []t2;//	delete []c;//}// // // //Задана матрица А(n*m).Сформировать массив В(m), каждый элемент которого равен кол-ву положительных эл-тов с суммой цифр, кратной трем в соответстующем столбце матрицы. Найти строку с макс. произведением эл-тов.//#include<iostream>//#include<iomanip>//#include<ctime>//using namespace std;//int summ(int num)//{//	int sum = 0;//	while (num > 0) {//		sum += num % 10;//		num /= 10;//	}//	return sum;//}//void f_rand(int** tf, int nf, int mf, int r_min, int r_max)//{//	srand((unsigned int)time(NULL));//	for (int i = 0; i < nf; i++)//		for (int j = 0; j < mf; j++)//			tf[i][j] = rand() % (r_max - r_min) + r_min;//	return;//}//void f_print(int** tf, int nf, int mf)//{//	cout << endl;//	for (int i = 0; i < nf; i++) {//		for (int j = 0; j < mf; j++)//			cout << setw(6) << tf[i][j];//		cout << endl;//	}//	return;//}//int main()//{//	int n, m,*B;//	cout << "strok "; cin >> n;//	cout << "stolbcov "; cin >> m;//	B = new int [m];//	int **A = new int* [n];//	for (int i = 0; i < n; i++)//		A[i] = new int[m];//	f_rand(A, n, m, -10, 10);//	cout << "matrix A";//	f_print(A, n, m);//	for (int j = 0; j < m; j++) {//		int count = 0;//		for (int i = 0; i < n; i++) {//			if (A[i][j] > 0 && summ(A[i][j]) % 3 == 0) {//				count++;//			}//				//		}//		B[j] = count;//	}//	cout << "Massiv B:"<<endl;//	for (int i = 0; i < m; i++) {//		cout <<setw(6) << B[i]<<endl;//	}//	int max_product = -100, max_product_row = -1;//	for (int i = 0; i < n; i++) {//		int product = 1;//		for (int j = 0; j < m; j++) {//			product *= A[i][j];//		}//		if (product > max_product) {//			max_product = product;//			max_product_row = i;//		}//	}//	cout << "str s max proizvedeniem el-tov " << max_product_row+1;//////	return 0;//	delete []A;//	delete []B;//}//Матрица A(n*n) является симметричной, если выполняется св-во A(транспонированная) == A.//Вычислить A^(-1). Убедиться A * A^(-1) = E//#include<iostream>//#include<iomanip>//#include<ctime>//#include<cmath>//using namespace std;//int slau(double **matrica_a, int n, double *massiv_b, double *x)//{//	int i, j, k, r;//	double c, M, max, s;//	double** a, * b;//	a = new double* [n];//	for (i = 0; i < n; i++)//		a[i] = new double[n];//	b = new double[n];//	for (i = 0; i < n; i++) //	{//		for (j = 0; j < n; j++)//			a[i][j] = matrica_a[i][j];//	}//	for (i = 0; i < n; i++)//		b[i] = massiv_b[i];//	for (k = 0; k < n; k++)//	{//		max = fabs(a[k][k]);//		r = k;//		for (i = k + 1; i < n; i++)//			if (fabs(a[i][k]) > max)//			{//				max = fabs(a[i][k]);//				r = i;//			}//		for (j = 0; j < n; j++)//		{//			c = a[k][j];//			a[k][j] = a[r][j];//			a[r][j] = c;//		}//		c = b[k];//		b[k] = b[r];//		b[r] = c;//		for (i = k + 1; i < n; i++)//		{//			for (M = a[i][k] / a[k][k], j = k; j < n; j++)//				a[i][j]-=M*a[k][j];//			b[i]-=M*b[k];//		}//	}//	if(a[n-1][n-1] == 0)//		if(b[n-1] == 0)//			return -1;//		else return -2;//	else//	{//		for(i = n-1; i >= 0; i--)//		{//			for(s = 0 , j = i + 1; j < n; j++)//			s+=a[i][j]*x[j];//			x[i]=(b[i]-s) / a[i][i];//		}//		return 0;//	}//	for(i = 0; i < n; i++)//	delete[] a[i];//	delete[] a;//	delete[] b;////}//int inv(double **a, int n, double **y)//{//	int i, j, res;//	double *b, *x;//	b=new double[n];//	x=new double[n];//	for(i = 0; i < n; i++)//	{//		for(j = 0; j < n; j++)//			if(j == i)//				b[j] = 1;//		else b[j] = 0;//		res = slau(a,n,b,x);//		if(res != 0)//			break;//		else//		for(j = 0; j < n; j++)//			y[j][i] = x[j];//	}//	if (res != 0)//		return -1;//	else//		return 0;//}//int main()//{//	double A[4][4] = { {1,0.42,0.54,0.66},{0.42,1,0.32,0.44},{0.54,0.32,1,0.22},{0.66,0.44,0.22,1} };//	cout << "matrix A" << endl;//	for (int i = 0; i < 4; i++)//	{//		for (int j = 0; j < 4; j++)//			cout << setw(6) << A[i][j];//		cout << endl;//	}//	double At[4][4];//	for (int i = 0; i < 4; ++i)//	{//		for (int j = 0; j < 4; ++j)//		{//			At[i][j] = A[j][i];//		}//	}//	cout << "matrix A^t" << endl;//	for (int i = 0; i < 4; i++)//	{//		for (int j = 0; j < 4; j++)//			cout << setw(6) << At[i][j];//		cout << endl;//	}//	//	int flag=0;//	for (int i=0;i<4;i++) //	{//		for (int j = 0; j < 4; j++)//		{//			if (At[i][j] == A[i][j]) //			{//				flag=1;//			}//		}//	}//	if (flag == 1) {//		cout << "A^t == A" << endl;//	}//	else cout<< "A^t != A" << endl;//	double **dA = new double* [4];//	for (int i = 0; i < 4; ++i) {//		dA[i] = new double[4];//		for (int j = 0; j < 4; ++j) {//			dA[i][j] = A[i][j];//		}//	}//	double** dAo = new double* [4];//	for (int i = 0; i < 4; ++i) {//		dAo[i] = new double[4];//		for (int j = 0; j < 4; ++j) {//			dAo[i][j] = A[i][j];//		}//	}//	int result;//	result = inv(dA,4, dAo);//	cout << "A^(-1)" << endl;//	for (int i = 0; i < 4; i++)//	{//		for (int j = 0; j < 4; j++)//			cout << setw(12) << dAo[i][j];//		cout << endl;//	}//	int** e = new int* [4];//	for (int i = 0; i < 4; i++)//	{//		e[i] = new int[4];//	}//	//for (int i = 0; i < 4; i++)//	//{//	//	for (int j = 0; j < 4; j++)//	//	{//	//		arr3[i][j] = 0;//	//		for (int k = 0; k < 1; k++)//	//		{//	//			arr3[i][j] += dA[i][j] * dAo[j][i];//	//		}//	//	}//	//}//	for (int i = 0; i < 4; i++)//	{//		for (int j = 0; j < 4; j++)//		{//			e[i][j] = dA[i][j] * dAo[i][j];//		}//	}//	cout << "proizved matrix" << endl;//	for (int i = 0; i < 4; i++)//	{//		for (int j = 0; j < 4; j++)//			cout << setw(15) << e[i][j];//		cout << endl;//	}////	delete[] e;//	delete[] dA;//	delete[] dAo;//	return 0;//}//laba3variant18//Случайным образом создать таблицу пар значений и записать её в текстовый файл в виде ://a b c//5.2 4.6 2.5 можно//1.2 8.9 2.3//Cчитать из файла записанные данные и определить, можно ли построить треугольник соответствующие строки таблицы.//#include <stdio.h>//#include <stdlib.h>//#include <iostream>//#include <time.h>//using namespace std;//bool tri(float a, float b, float c)//{//	if (//		(a<b+c)&&//		(b<a+c)&&//		(c<a+b)//		)//		return 1;//	else return 0;//}//void main()//{//	srand((unsigned)time(0));//	int n = 0;//	cout << "Skolko znacheniy : ";cin >> n; //	FILE* f = fopen("ishod.txt", "w");  //	fprintf(f, "a\tb\tc\n");//	for (int i = 0; i < n; i++) {//		float a, b, c;//		a = rand() % 100 * 0.1;//		b = rand() % 100 * 0.1;//		c = rand() % 100 * 0.1;//		fprintf(f, "%f\t%f\t%f\n", a, b, c);//	}//	fclose(f);//	f = fopen("ishod.txt", "r"); //	FILE* g = fopen("otvet.txt", "w"); //	while (fgetc(f) != '\n') ;//	fprintf(g, "a\tb\tc\n");//	while (!feof(f)) //	{//		float x, y, z;//		fscanf(f, "%f\t%f\t%f\n", &x, &y, &z);//		if (tri(x, y, z))//			fprintf(g, "%f\t%f\t%f\tmozhno\n", x, y, z);//		else//			fprintf(g, "%f\t%f\t%f\n", x, y, z);//	}//	fclose(g);//	fclose(f);//}//Упорядочить значения двоичного файла,содержащего данные типа char по алфавиту//#include <iostream>//#include <fstream>//#include <algorithm>//using namespace std;//int main() {//    const char* filename = "ishodbin.bin";//    ofstream out(filename, ios::binary);//    char data[] = { 'f', 'e', 'd', 'c', 'b', 'a' };//    out.write(data, sizeof(data));//    out.close();//    ifstream in(filename, ios::binary);//    in.seekg(0, ios::end);//    int file_size = in.tellg();//    in.seekg(0, ios::beg);//    char* buffer = new char[file_size];//    in.read(buffer, file_size);//    sort(buffer, buffer + file_size);//    in.close();//    ofstream sorted_out("otvetbin.bin", ios::binary);//    sorted_out.write(buffer, file_size);//    sorted_out.close();//    delete[] buffer;//    return 0;//}//Определить количество пробелов в чётных строках текста//#include <iostream>//#include <fstream>//#include <string>//using namespace std;//int main()//{//    ifstream fin("text.txt");//    int lineNum = 0;//    string line;//    while (getline(fin, line))//    {//        lineNum++;//        if (lineNum % 2 == 0)//        {//            int spacesCount = count(line.begin(), line.end(), ' ');//            cout << "Stroka " << lineNum << " imeet " << spacesCount << " probelov" << endl;//        }//    }//    fin.close();//    return 0;//}// // //#include <iostream>#include <string>using namespace std;struct biblioteka{	int udk;	string fio_avtora;	string nazvanie;	int god;	int kolvo;	biblioteka* next;};typedef biblioteka *Pbiblioteka;Pbiblioteka CreateNode(int new_udk, string new_fio_avtora,string new_nazvanie,int new_god,int new_kolvo){	Pbiblioteka NewNode = new biblioteka;	NewNode->udk = new_udk;	NewNode->fio_avtora = new_fio_avtora;	NewNode->nazvanie = new_nazvanie;	NewNode->god = new_god;	NewNode->kolvo = new_kolvo;	NewNode->next = NULL;	return NewNode;}void AddFirst(Pbiblioteka& Head, Pbiblioteka NewNode){	NewNode->next = Head;	Head = NewNode;}void AddAfter(Pbiblioteka p, Pbiblioteka NewNode){	NewNode->next = p->next;	p->next = NewNode;}void Addbefore(Pbiblioteka& Head, Pbiblioteka p, Pbiblioteka NewNode){	Pbiblioteka q = Head;	if (Head == p)	{		AddFirst(Head, NewNode);		return;	}	while (q->next !=p && q!=NULL)		q = q->next;	if (q!=NULL)AddAfter(q, NewNode);}void Addlast(Pbiblioteka& Head, Pbiblioteka NewNode){	Pbiblioteka q = Head;	if (Head == NULL)	{		AddFirst(Head, NewNode);		return;	}	while (q->next)q = q->next;	AddAfter(q, NewNode);}void DeleteNode(Pbiblioteka& Head, Pbiblioteka OldNode){	Pbiblioteka q = Head;	if (Head == OldNode)		Head = OldNode->next;	else	{		while (q->next!=OldNode && q!=NULL)			q = q->next;		if (q == NULL) return;		q->next = OldNode->next;	}	delete OldNode;}Pbiblioteka input(){	int udk;	string fio_avtora;	string nazvanie;	int god;	int kolvo;	cout << "Vvedite nomer UDK" << endl; cin >> udk;	cout << "Vvedite F.I.O. avtora" << endl; cin >> fio_avtora;	cout << "Vvedite nazvanie knigi" << endl; cin >> nazvanie;	cout << "Vvedite god izdaniya" << endl; cin >> god;	cout << "Vvedite kolichestvo dannoi knigi" << endl; cin >> kolvo;	return CreateNode(udk, fio_avtora, nazvanie, god, kolvo);}void all(Pbiblioteka& Head){	Pbiblioteka q = Head;	int num = 1;	if (q == NULL)	{		cout << "Spisok pust!" << endl;	}	while (q != NULL)	{		cout << "Kniga Nomer: " << num << endl;		cout << "Nomer UDK " << q->udk << endl;		cout << "F.I.O. avtora " << q->fio_avtora << endl;		cout << "Nazvanie knigi " << q->nazvanie << endl;		cout << "God izdaniya " << q->god << endl;		cout << "Kolichestvo dannoi knigi " << q->kolvo << endl;		cout << " " << endl;		q = q->next;		num++;	}}Pbiblioteka searchnomer(Pbiblioteka& Head, int nom){	Pbiblioteka c = Head;	bool f = false;	do	{		if (c->udk == nom)		{			return c;			f = true;		}		c = c->next;	} while (c != NULL);	if (f == false)		cout << "kniga s takim nomerom ne naidena!" << endl;}void menu(){	cout << "0 - exit" << endl;//+	cout << "1 - vivod biblioteki" << endl;//+	cout << "2 - dobavlenie knigi otsortirovannoi po avtoru" << endl;//+-	cout << "3 - dobavlenie knigi pered ukazanoi knigoi" << endl;//+	cout << "4 - dobavlenie knigi posle ukazanoi knigoi" << endl;//+	cout << "5 - udalenie knigi" << endl;//+	cout << "6 - vidacha knigi" << endl;//+	cout << "7 - vozvrat knigi" << endl;//+	cout << "8 - nalichie knigi" << endl;}Pbiblioteka trytotake(Pbiblioteka& Head,int udc){	Pbiblioteka c = Head;	bool f = false;	while (c)	{		if (c->udk == udc)		{			f = true;			if (c->kolvo > 0)			{				cout << "Vi vzyali knigu\n";				c->kolvo--;				return c;			}			else				cout << "Knigu zabrali\n";			break;		}		c = c->next;	}	if (f == false)		cout << "Net takogo UDK\n";}Pbiblioteka returnbook(Pbiblioteka& Head,int udc){	bool f = false;	Pbiblioteka c = Head;	while (c)	{		if (c->udk == udc)		{			cout << "Kniga vozvrashena\n";			c->kolvo++;			f = true;			break;		}		c = c->next;	}	if (f == false)		cout << "Net takogo UDK\n";}int main(){	int t = -1;	Pbiblioteka head = NULL;	do	{		menu();		cin >> t;		switch (t)		{		case 1:		{			all(head);			system("pause");			break;		}		case 2:		{			Pbiblioteka NewKniga = input();			Addlast(head, NewKniga);			cout << "Kniga dobavlena!" << endl;			system("pause");			break;		}		case 3:		{			cout << "Vvedite knigu, kotoriy nado vstavit:" << endl;			Pbiblioteka NewKniga = input();			int n;			cout << "Vvedite nomer knigi pered kotoroi nuzhno vstavit:" << endl; cin >> n;			Pbiblioteka PeredK = searchnomer(head, n);			if (PeredK != NULL)			{				Addbefore(head, PeredK, NewKniga);				cout << "Kniga vstavlena!" << endl;			}			else				cout << "Ne udalos vstavit knigu!" << endl;			system("pause");			break;		}		case 4:		{			cout << "Vvedite knigu, kotoriy nado vstavit:" << endl;			Pbiblioteka NewKniga = input();			int s;			cout << "Vvedite nomer knigi posle kotoroi nuzhno vstavit:" << endl; cin >> s;			Pbiblioteka kniga = searchnomer(head, s);			if (kniga != NULL)			{				AddAfter(kniga, NewKniga);				cout << "Kniga vstavlena!" << endl;			}			else				cout << "Ne udalos vstavit knigu!" << endl;			system("pause");			break;		}		case 5:		{			if (head != NULL)			{				int m;				cout << "Vvedite nomer knigi, kotoriy nado udalit" << endl; cin >> m;				Pbiblioteka kniga = searchnomer(head, m);				if (kniga != NULL)				{					DeleteNode(head, kniga);					cout << "Kniga udalena" << endl;				}			}			else				cout << "Spisok pust!" << endl;			system("pause");			break;		}		case 6:		{			if (head != NULL)			{				int udk0;				cout << "kakoi udk" << endl; cin >> udk0;				Pbiblioteka kniga = trytotake(head,udk0);			}			else				cout << "Spisok pust!" << endl;			system("pause");		}		case 7:		{			if (head != NULL)			{				int udk1;				cout << "kakoi udk" << endl; cin >> udk1;				Pbiblioteka kniga = trytotake(head, udk1);			}			else				cout << "Spisok pust!" << endl;			system("pause");		}		case 8:		{		}		}	} while (t != 0);}// // // // //#include <iostream>//#include <string>//using namespace std;//struct biblioteka//{//	int udk;//	string fio_avtora;//	string nazvanie;//	int god;//	int kolvo;//	biblioteka* next,*prev;//};//typedef biblioteka* Pbiblioteka;//struct Stack//{//	Pbiblioteka Head, Tail;//};//void Push(Stack& S, int new_udk, string new_fio_avtora, string new_nazvanie, int new_god, int new_kolvo)//{//	Pbiblioteka NewNode = new biblioteka;//	NewNode->udk = new_udk;//	NewNode->fio_avtora = new_fio_avtora;//	NewNode->nazvanie = new_nazvanie;//	NewNode->god = new_god;//	NewNode->kolvo = new_kolvo;//	NewNode->next = S.Head;//	NewNode->prev = NULL;//	if (S.Head)//		S.Head->prev = NewNode;//	S.Head = NewNode;//	if (!S.Tail) S.Tail = S.Head;//}//#include <iostream>//#include <string>//using namespace std;//const int MAXSIZE = 100; //struct Book//{ //    string udc; //    string author; //    string title;//    int year;//    int quantity; //};//struct Stack//{//    int top; //    Book data[MAXSIZE];//};//void init(Stack& s)//{ //    s.top = -1;//}//bool isEmpty(const Stack& s)//{ //    return s.top == -1;//}//bool isFull(const Stack& s)//{ //    return s.top == MAXSIZE - 1;//}////void push(Stack& s, const Book& book)//{//    if (isFull(s))//    {//        cout << "Stack perepolnen \n";//        return;//    }//    s.data[++s.top] = book;//}//void pop(Stack& s)//{ //    if (isEmpty(s))//    {//        cout << "Stack ne zapolnen \n";//        return;//    }//    --s.top;//}//void display(const Stack& s)//{//    if (isEmpty(s))//    {//        cout << "Stack pust\n";//        return;//    }//    cout << "Stack contents:\n";//    for (int i = s.top; i >= 0; --i)//    {//        cout << "UDK: " << s.data[i].udc << "\n";//        cout << "Avtor: " << s.data[i].author << "\n";//        cout << "Nazvanie: " << s.data[i].title << "\n";//        cout << "God: " << s.data[i].year << "\n";//        cout << "kolvo: " << s.data[i].quantity << "\n\n";//    }//}//int main() {//    Stack s;//    init(s);//    Book b1 = { "123", "Ivanov I.I.", "Kniga 1", 1990, 5 };//    push(s, b1);//    Book b2 = { "678", "Petrov P.P.", "Kniga 2", 2000, 3 };//    push(s, b2);//    Book b3 = { "777", "Sidorov S.S.", "Kniga 3", 2010, 10 };//    push(s, b3);//    display(s);//    pop(s);//    cout << "After popping:\n";//    display(s);//    return 0;//}//#include <iostream>//#include <string>//using namespace std;//struct Book//{//    string udc;    //    string author; //    string title;  //    int year;      //    int quantity;  //};//struct QueueNode//{//    Book book; //    QueueNode* next = nullptr; //};//struct Queue//{//    QueueNode* head = nullptr; //    QueueNode* tail = nullptr; //    void enqueue(const Book& book)//    {//        QueueNode* node = new QueueNode{ book };//        if (tail == nullptr)//        {//            head = tail = node;//        }//        else//        {//            tail->next = node;//            tail = node;//        }//    }//    Book dequeue() {//        if (head == nullptr)//        { //            return { "", "", "", 0, 0 };//        }//        Book book = head->book;//        QueueNode* temp = head;//        head = head->next;//        delete temp;//        if (head == nullptr)//        { //            tail = nullptr;//        }//        return book;//    }//    Book getHead() //    {//        if (head == nullptr) //        {//            return { "", "", "", 0, 0 };//        }//        return head->book;//    }//    bool isEmpty() //    {//        return head == nullptr;//    }//};//int main() //{//    Queue queue;//    queue.enqueue({ "777", "Sidorov S.S.", "Kniga 3", 2010, 10 });//    queue.enqueue({ "678", "Petrov P.P.", "Kniga 2", 2000, 3 });//    queue.enqueue({ "777", "Sidorov S.S.", "Kniga 3", 2010, 10 });//    while (!queue.isEmpty()) //    {//        Book book = queue.dequeue();//        cout << "UDK: " << book.udc << endl;//        cout << "Avtor: " << book.author << endl;//        cout << "Nazvanie: " << book.title << endl;//        cout << "God: " << book.year << endl;//        cout << "Kolvo: " << book.quantity << endl << endl;//    }//    return 0;//}//#include <iostream>//using namespace std;//class TrainCar {//private://    int carNumber;//    string carClass;//    int seatsCount;//public://    TrainCar(int number, string cl, int count) {//        carNumber = number;//        carClass = cl;//        seatsCount = count;//    }//    ~TrainCar() {}//    void passengersOut(int out) {//        if (out > 0 && out <= seatsCount)//            seatsCount -= out;//        else//            cout << "Некорректное значение количества пассажиров!" << endl;//    }//    void ticketsSold(int sold) { //        if (sold > 0 && sold <= seatsCount)//            seatsCount -= sold;//        else//            cout << "Некорректное значение количества проданных билетов!" << endl;//    }//    void freeSeats() {//        cout << "В вагоне №" << carNumber << " класса " << carClass << " осталось " << seatsCount << " свободных мест." << endl;//    }//};//int main()//{//    TrainCar first(1, "первый", 50);//    first.passengersOut(10);//    first.ticketsSold(5);//    first.freeSeats();//}